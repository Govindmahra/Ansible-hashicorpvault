pipeline {
    agent any

    environment {
                AWS_CREDENTIALS_ID = 'aws_cred'                       // AWS credentials ID
                AWS_REGION = 'us-east-1' // Replace with your AWS region if needed
    }

    stages {
        stage('cloning repo') {
            steps {
                git "https://github.com/Govindmahra/Hasicorp-vault.git"
            }
        }

        stage('Terraform Init') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh '''
                            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                            terraform init
                        '''
                    }
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                    dir("${TERRAFORM_DIR}") {
                        script {
                            sh '''
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                terraform apply -auto-approve
                            '''
                            def bastionHost = sh(script: 'terraform output -raw public_instance_ip_out', returnStdout: true).trim()
                            echo "Bastion Host IP: ${bastionHost}"
                            env.BASTION_HOST = bastionHost
                        }
                    }
                }
            }
        }

       // stage('Attach IAM Policy') {
        //     steps {
        //         script {
        //             // Attach the policy to the role
        //             sh '''
        //                 aws iam attach-role-policy --role-name ${ROLE_NAME} --policy-arn ${POLICY_ARN} --region ${AWS_REGION}
        //             '''
        //         }
        //     }
        // }
    }

    post {
        always {
            script {
                def destroy = 'no'

                if (currentBuild.result == 'FAILURE') {
                    destroy = input(id: 'userInputFailure', message: 'Pipeline failed. Do you want to destroy the infrastructure?', parameters: [choice(name: 'confirm', choices: ['no', 'yes'], description: 'Choose yes to destroy, no to cancel.')])
                } else if (currentBuild.result == 'SUCCESS') {
                    destroy = input(id: 'userInputSuccess', message: 'Pipeline succeeded. Do you want to destroy the infrastructure?', parameters: [choice(name: 'confirm', choices: ['no', 'yes'], description: 'Choose yes to destroy, no to keep.')])
                }

                if (destroy == 'yes') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                        dir("${TERRAFORM_DIR}") {
                            sh '''
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                terraform destroy -auto-approve
                            '''
                        }
                    }
                }
            }
        }
    }
}
