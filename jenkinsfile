pipeline {
    agent any

    environment {
        AWS_ACCESS_KEY_ID     = credentials('govind_access_key')
        AWS_SECRET_ACCESS_KEY = credentials('govind_secret_key')

        AWS_CREDENTIALS_ID = 'aws_cred'                       // AWS credentials ID
        TERRAFORM_REPO = 'https://github.com/Govindmahra/Hasicorp-vault.git' // Terraform repo URL
        ANSIBLE_REPO = 'https://github.com/Govindmahra/Ansible-hashicorpvault.git' // Ansible repo URL
        ANSIBLE_PLAYBOOK = 'vault.yml'                       // Ansible playbook file
        INVENTORY_FILE = 'aws_ec2.yml'                       // Ansible inventory file
        TERRAFORM_DIR = 'infra'                              // Directory where Terraform code is located
        PRIVATE_KEY_FILE = '/var/lib/jenkins/infra/vault_key.pem' // Path to the private key file
        BASTION_USER = 'ubuntu'                              // Bastion host user
        POLICY_ARN = 'arn:aws:iam::448014237739:role' // Replace with your policy ARN
        INSTANCE_PROFILE_ARN= 'arn:aws:iam::448014237739:instance-profile/cli'
        ROLE_NAME = 'cli' // Your role name
        AWS_REGION = 'us-east-1' // Replace with your AWS region if needed
    }

    stages {
        stage('Checkout Terraform Code') {
            steps {
                git branch: 'main', url: "${TERRAFORM_REPO}"
            }
        }

        stage('Terraform Init') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh '''
                            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                            terraform init
                        '''
                    }
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                    dir("${TERRAFORM_DIR}") {
                        script {
                            sh '''
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                terraform apply -auto-approve
                            '''
                            def bastionHost = sh(script: 'terraform output -raw public_instance_ip_out', returnStdout: true).trim()
                            echo "Bastion Host IP: ${bastionHost}"
                            env.BASTION_HOST = bastionHost
                        }
                    }
                }
            }
        }

        stage('Install AWS CLI') {
            steps {
                script {
                    // Check if AWS CLI is installed
                    def awsCliVersion = sh(script: 'aws --version', returnStatus: true)
                    if (awsCliVersion != 0) {
                        echo 'AWS CLI not found. Installing...'
                        sh 'sudo snap install aws-cli --classic'
                    } else {
                        echo 'AWS CLI is already installed.'
                    }
                }
            }
        }

        // stage('Attach IAM Policy') {
        //     steps {
        //         script {
        //             // Attach the policy to the role
        //             sh '''
        //                 aws iam attach-role-policy --role-name ${ROLE_NAME} --policy-arn ${POLICY_ARN} --region ${AWS_REGION}
        //             '''
        //         }
        //     }
        // }

        stage('Checkout Ansible Code') {
            steps {
                git branch: 'main', url: "${ANSIBLE_REPO}"
            }
        }

        stage('Copy Key and Ansible Code to Bastion Host') {
            steps {
                script {
                    def bastionHost = env.BASTION_HOST
                    def privateKeyFile = env.PRIVATE_KEY_FILE
                    def bastionUser = env.BASTION_USER
                    echo "Bastion Host IP for SCP: ${bastionHost}"

                    if (!fileExists(privateKeyFile)) {
                        error "Private key file not found: ${privateKeyFile}"
                    }

                    sh """
                        scp -o StrictHostKeyChecking=no -i ${privateKeyFile} ${privateKeyFile} ${bastionUser}@${bastionHost}:/home/${bastionUser}/.ssh
                        ssh -o StrictHostKeyChecking=no -i ${privateKeyFile} ${bastionUser}@${bastionHost} "
                        export PATH=\$PATH:/home/ubuntu/.local/bin &&
                        git clone ${ANSIBLE_REPO} /home/ubuntu/Ansible-hashicorpvault &&
                        sudo apt-get update &&
                        sudo apt-get install -y python3 python3-pip &&
                        pip3 install --user boto boto3 botocore ansible"
                    """
                }
            }
        }

        stage('Run Ansible Playbook') {
            steps {
                script {
                    def bastionHost = env.BASTION_HOST
                    echo "Bastion Host IP for Ansible Playbook: ${bastionHost}"
                    sh '''
                        ssh -o StrictHostKeyChecking=no -i ${PRIVATE_KEY_FILE} ${BASTION_USER}@${BASTION_HOST} "
                        /home/ubuntu/.local/bin/ansible-playbook /home/${BASTION_USER}/Ansible-hashicorpvault/${ANSIBLE_PLAYBOOK} -i /home/${BASTION_USER}/Ansible-hashicorpvault/${INVENTORY_FILE}"
                    '''
                }
            }
        }
    }

    post {
        always {
            script {
                def destroy = 'no'

                if (currentBuild.result == 'FAILURE') {
                    destroy = input(id: 'userInputFailure', message: 'Pipeline failed. Do you want to destroy the infrastructure?', parameters: [choice(name: 'confirm', choices: ['no', 'yes'], description: 'Choose yes to destroy, no to cancel.')])
                } else if (currentBuild.result == 'SUCCESS') {
                    destroy = input(id: 'userInputSuccess', message: 'Pipeline succeeded. Do you want to destroy the infrastructure?', parameters: [choice(name: 'confirm', choices: ['no', 'yes'], description: 'Choose yes to destroy, no to keep.')])
                }

                if (destroy == 'yes') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${AWS_CREDENTIALS_ID}"]]) {
                        dir("${TERRAFORM_DIR}") {
                            sh '''
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                terraform destroy -auto-approve
                            '''
                        }
                    }
                }
            }
        }
    }
}
